package controllers

import (
	"context"
	"errors"
	"fmt"
	"mime/multipart"

	apierrors "github.com/TheSandyDave/Media-Tags/api_errors"
	"github.com/TheSandyDave/Media-Tags/conversion"
	"github.com/TheSandyDave/Media-Tags/domain"
	restgen "github.com/TheSandyDave/Media-Tags/generated/api"
	"github.com/TheSandyDave/Media-Tags/services"
	"github.com/TheSandyDave/Media-Tags/utils"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type MediaController struct {
	MediaService services.IMediaService
	TagService   services.ITagService
}

func (controller *MediaController) GetMedia(c *gin.Context) {
	type inputFilters struct {
		Tag string `form:"tag"`
	}

	list(c, func(ctx context.Context, input inputFilters) ([]*restgen.Media, error) {
		var opts = []services.Option[domain.Media]{}
		if input.Tag != "" {
			opts = append(opts, controller.MediaService.FilterByTagOption(input.Tag))
		}

		media, err := controller.MediaService.Get(ctx, opts...)
		if err != nil {
			return nil, err
		}

		return conversion.EncodeSlice(media, conversion.EncodeMedia), nil
	})
}

func (controller *MediaController) GetMediaWithId(c *gin.Context) {
	getWithID(c, func(ctx context.Context, id uuid.UUID) (*restgen.Media, error) {
		media, err := controller.MediaService.GetWithID(ctx, id)
		if err != nil {
			return nil, err
		}

		return conversion.EncodeMedia(media), nil
	})
}

func (controller *MediaController) CreateTag(c *gin.Context) {

	// Autogenerated input structs don't behave nicely with form data, just make it on the spot
	type createMediaInput struct {
		Name string                `form:"name"`
		Tags []string              `form:"tags"`
		File *multipart.FileHeader `form:"file"`
	}
	create(c, func(ctx context.Context, input createMediaInput) (*restgen.Media, error) {
		//TODO: actual file upload

		// Check that all the tags actually exist
		tagIds, err := utils.StringSliceToUUID(input.Tags)
		if err != nil {
			return nil, err
		}

		tags, err := controller.TagService.GetWithIDs(ctx, tagIds)
		if err != nil {
			recordsNotFoundError, ok := err.(*apierrors.RecordsNotFoundWithIDs)
			if ok {
				return nil, apierrors.NewInvalidTagsError(recordsNotFoundError.IDs)
			} else {
				return nil, err
			}
		}
		if input.File == nil {
			return nil, errors.New("Missing file")
		}
		media := &domain.Media{
			Name:    input.Name,
			Tags:    tags,
			FileUrl: fmt.Sprintf("placeholder.domain/%s", input.File.Filename),
		}

		if err := controller.MediaService.Create(ctx, media); err != nil {
			return nil, err
		}

		return conversion.EncodeMedia(media), nil
	})
}
